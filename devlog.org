#+TITLE:   Devlog/Ideas
#+AUTHOR:  Jon Raphaelson
#+EMAIL:   jon@accidental.cc

* <2023-12-10 Sun> nicer pseudos

with the ability to "descope" labels (refer to the same name at a higher scope
explicitly), we're able to do some nifty ~pseudo~ macros without running into
label naming conflicts.

next is to really dig into the COMFY core stuff that sassy uses, which, _surprise_
is based on an H. Baker paper: [[https://web.archive.org/web/20180208043127/http://home.pipeline.com/~hbaker1/sigplannotices/COMFY.TXT][a comfortable set of control primitives for asm programming]]

#+begin_src scheme
  (pseudo (delay reg count)
    `((mov ,reg ,count)
      (scope
        (subs ,reg ,reg 1)
        (b ?ne $enter))))

  (pseudo (if cond then else)
    `((scope
        (scope
          (b ,(condition-invert cond) $exit)
          ,@then
          (b $exit^)))
      ,@else))

  (pseudo (when cond . then)
    `(scope
       (b ,(condition-invert cond) $exit)
       ,@then))

  (pseudo (while test cond . then)
    `(scope
       ,test
       (b ,(condition-invert cond) $exit)
       ,@then
       (b $enter)))

  ;; ---

  (block main ()
    (bl some-function-that-sets-flags)
    (when ?ne
      (delay r9 150)))

  ;; --- expands to:

  (block main ()
    (bl some-function-that-sets-flags)
    (b ?eq $exit)   ;; scoped to the when, +10 or whatever
    (mov r9 150)
    (subs r9 r9 1)
    (b ?ne $enter)) ;; scoped to the deloy, -4
#+end_src

* <2023-12-09 Sat> emacs mode

there's a simple emacs major mode for "miriam scheme" now, which
automatically sets up some of the indentation for macros and syntax
highlighting for the assembler.

I'll probably break it up into "miriam-scheme" and "miriam-asm" modes,
since I'll want to not have the highlighting on ~pseudo~ and the like
in the scheme code, but for now it's pretty nice.

-- blog post idea: how to do that?

For now, everything is just nicely setup in the ~.dir-locals.el~ file;
just opening a file in the project in emacs will prompt and then apply
everything.

If it's ever a necessity to export it, it'll need more clean up.

* <2023-12-09 Sat> assembler: multi-module

I'm realizing, reading examples of getting various peripherals up, that I need a linker.

- I need some kind of serializable output format (elf but s-expr)
- I need some kind of "module" system in the assembler, so that I can collect modules and layout them out
- I want to be able to <import>, rather than <include>

- a module has _assemble-time_ parts, and _run-time_ parts
  - assemble-time: pseudos, definitions, relocation/link-instructions?
  - run-time: actual code blocks, data sections

** plan

- write a filesystem abstraction
- ~assemble~ takes a module name outputs a "module"
  - from an assembly file:
  - ~(import (some module name))~ makes environment and exports available
  - ~(import comp (same module name))~ makes only the environment available (pseudos and comptime functions)
- a module looks kinda like:
  - exports are label+data offset which are intended to be resolvable from other modules
  - imports are relocs from other modules, which can't be resolved until the modules are finally laid out
  #+begin_src prog
    (%module
      (name with path)
      (exports
        (label offset)
        (label offset))
      (imports
        (reloc-type offset (label (module name with path)))
        (reloc-type offset (label (module name with path))))
      (data #vu8()))
  #+end_src
- linking the final executable image:
  - topological sort dependencies, and figure out runtime offsets
  - in order of dependencies:
    - write out module's bytestream
    - fixup any outstanding relocations

* <2023-12-09 Sat> data representation

a _value_ is a (little-endian) 32-bit word
a _value_ can be either an _immediate_ or an _object_

an _object_    is a pointer to an objects header word
an _immediate_ is any 32-bit word that is non-zero in the low two bits

ergo, "unaligned pointers" represent immediates

constraints:
-- we can only mask-test 8-bits at a time with arm instructions

** immediates

#+begin_src
(little endian, low byte is first)
76543210 FEDCBA98 76543210 FEDCBA98

type     data
xxxx0001 xxxxxxxx xxxxxxxx xxxxxxxx <- fixnum (28bit signed int)
xxxx0010 xxxxxxxx xxxxxxxx xxxxxxxx <- utf-8 codepoint (weird encoding, but single-byte encoding is simple still)
xxxx0011 xxxxxxxx xxxxxxxx xxxxxxxx <-
xxxx0101 xxxxxxxx xxxxxxxx xxxxxxxx <-
xxxx0110 xxxxxxxx xxxxxxxx xxxxxxxx <-
xxxx0111 xxxxxxxx xxxxxxxx xxxxxxxx <-
xxxx1001 xxxxxxxx xxxxxxxx xxxxxxxx <-
xxxx1010 xxxxxxxx xxxxxxxx xxxxxxxx <-
xxxx1011 xxxxxxxx xxxxxxxx xxxxxxxx <-
xxxx1101 xxxxxxxx xxxxxxxx xxxxxxxx <-
xxxx1110 xxxxxxxx xxxxxxxx xxxxxxxx <- nil
xxxx1111 xxxxxxxx xxxxxxxx xxxxxxxx <- undefined
#+end_src

** objects
*** object header

#+begin_src
gc info  type     size
76543210 FEDCBA98 76543210 FEDCBA98

ggggtttt ssssssss ssssssss ssssssss

g7 = forwarded?
g6 = special? (skipped by gc)
g5 = align?   (align based on size)
g3 =

t  = type
s  = size (in words if align?)
#+end_src

* <2023-12-08 Fri>
** interesting instructions

_turns out these are thumb only_

some instructions not to forget about:
- cbnz, cbz
  - compare and branch on nonzero/zero
  - ~cbz rn, label~ == ~cmp rn, 0; b ?eq label~
  - ~cbnz rn, label~ == ~cmp rn, 0; b ?ne label~
- tbb, tbh
  - test and branch byte/half-word
  - causes a PC-relative forward branch from a table of single-byte or half-word offsets

* <2023-12-07 Thu>

general outline of the runtime system, based on a bunch of reading that I've been doing:

- cps conversion + cheney/mta style garbage collection
- the stack is the nursery of the garbage collectior
- "heap allocation" is pushing to the stack
- when the stack hits the end of it's page, minor GC
    - this will scan the stack page, copy out objects to the old-space
    - then trash the stack page and teturn a new one, with
- heap allocation is simply pushing to the stack
- limit the stack size to a page
    - when a requested allocation hits the page boundary, minor GC
    - this will scan the _stack page_, copy out objects to some other pages, and then reset the stack pointer
    - with CPS this is straightforwardish

immutable first, like clojure
- it makes reasoning about things easier
- see [[https://web.archive.org/web/20200109080303/http://home.pipeline.com/~hbaker1/ObjectIdentity.html][this good paper on object identity]], which makes good cases for "everything is an immutable value,
  including the reference to a mutable box".

*** reading list

- [[https://web.archive.org/web/20191008050811/http://home.pipeline.com/~hbaker1/YoungGen.html][h. baker: 'infant mortality' and generational garbage collection]]
- [[https://web.archive.org/web/20191008012410/http://home.pipeline.com/~hbaker1/LazyAlloc.html][h. baker: cons should not cons it's arguments; lazy alloc]]
- [[https://web.archive.org/web/20200223051632/http://home.pipeline.com/~hbaker1/CheneyMTA.html][h. baker: cons should not cons it's arguments pt 2; cheny on the mta]]
- [[https://www.more-magic.net/posts/internals-gc.html][chicken internals: the garbage collector]]
- [[https://www.more-magic.net/posts/internals-data-representation.html][chicken internals: object representation]]
  - [[https://www.multicians.org/lcp.html][maclisp -- the basic hackery]] (bibop collection, 100% different than chicken, referenced)
- [[https://www.cs.princeton.edu/~appel/papers/142.pdf][a. appel: runtime tags aren't necessary]]

these are brilliant papers on utilizing the stack for the nursery of a generational garbage collector
the chicken paper in particular, since I'm much better at reading code examples

h. baker's papers are really really good you guys.

* <2023-12-06 Wed>

completely unrelated, it sucks that scheme doesn't have symbol macros.

I think miriam should have a few CL and clojure features added; the language can drift some scheme, absolutely.

- keywords! basically symbols, but can't be used in a calling position
  - especially if we end up doing symbol macros for things like generalized ~set!~, we need a simpler type than a symbol
    - a ~keyword~ is an interned string, which has pointer equality and is guaranteed to match
    - a ~symbol~ is a record, comprised of a keyword and attribute slots for ~set!~, ~get!~, possibly a metatable, etc.
- drop the syntactic tower and just use unhygenic macros
- use ~0x~ rather than ~#x~ for number syntaxes
  - that frees up the ~#~ for user-defined reader macros
- reader macros, such that we can define arbitrary new ~#something()~ syntaxes
  - ie. regex ~#/\d+/~, timestamps ~#t<1985-02-01T00:00:00.000000+06:00>~, xml ~#xml<foo><bar /></foo>~ etc.
    - these should probably support unquote, ie. ~#xml<foo type=,attr>,(gen-content)</foo>~
- some kind of generic method/multiple dispatch on user-provided predicates, rather than just ~case-lambda~
  - this is basically clos, or the ~metatable~ stuff from lua, metaclasses in ruby, prototypes from javascript
  - generalized ~set!~, with symbol macros allowing for deeply nested sets
    - that lets us create arbitrary "setters" for meta-functions
    - ie. ~(set! (set-handler 'accessor) set-accessor!)~, which might allow ~(set! (accessor x) value)~
  - similarly, a generalized get! - ie. ~(get object key)~ - corresponds to lua ~index~ metamethod
  - does this extend to ~make~, ie generalized constructors?
  - generic ~read~, ~write~ and ~display~
    - anything interesting to read here re: haskell optics, etc?
    - can we specialize these at compile time?
  - _method combiner_ in clos is cool:
    - you can specify on a generic function that, rather than only calling the most specific, you can use a
      different operator; ie. ~(defgeneric foo (obj) (:method-combination list))~ would run _all_ applicable
      methods and bundle values into a list; imagine ~fold~, ~begin~ etc. as combination operators
  - a lot of this is reminiscent of the ruby class hierarchy as well
    - ~prepend~ ~append~ modules for overrides?
- string interpolation (cheeky: ~"~ is a reader macro which compiles to a series of ~string:append~ calls)

you could think of the dotted record syntax like an expansion of the ~get!~ macro:

#+begin_src
  (list p.x p.y)   -> (list (get! p x) (get! p y)) -> (list (p-get-x p) (p-get-y p))
  (set! p.x 42)    -> (set! (get! p x) 42)         -> (set! (p-get-x p) 42)
  (p.something 50) -> ((get! p something) 50)      -> (p-something 50)
#+end_src

part of the reason I keep reaching for relatively inefficient cons and alists is that ~(asm-context asm)~
is almost as bad as (cadr asm) in terms of code-reading density; I'd much rather ~asm.context~.

see [[https://lispcookbook.github.io/cl-cookbook/cl21.html#features][cl21 (unofficial proposal for cleanup of commonlisp)]]

- ~^~ as a reader macro to give short lambdas
  - ~(map ^(+ 1 %) some-list)~
- some kind of automatic currying, possibly with a reader macro to defend against accidental calls
  - this may be less frustrating with the above macro

* <2023-12-06 Wed>

cleaned up the assembler a good bit; mostly encapsulating the context that gets passed around the
assembler functions; I may switch these all to take them implicitly, actually, since I moved
~assemble~ into being a function, rather than syntax.

additionally, started in on a really simple driver, pulling code from a file, rather than directly
inline.

** relocations

as I'm starting to think about global variables, I'm reading about how ELF does relocation for ARM,
and it's much more complicated than what I'm doing:

- me:
  - when a relocation is needed, store the _form_
  - when a relocation is resolved, _reassemble the form_ at the point, and replace

- elf:
  - when a relocation is needed, record the exact form of relocation
  - when relocation is resolved, the instruction at the offset is extracted, and reencoded by the instruction

  - relocation types (skipping thumb)
    - ~R_ARM_PC24~,    (b #imm24), pcrelative, "bits 0-23 signed offset in units of 4-byte words"
    - ~R_ARM_PC13~ ,   (ldr r #imm13) "bits 0-11 unsigned offset, bit 13 encodes direction (0 = -, 1 = +)"
    - ~R_ARM_ABS12~,   LDR/STR imm
    - ~R_ARM_SWI24~,   (swi #imm24)
    - explicitly sized, unencoded relocations
      - ~R_ARM_ABS32~,   any 32-bit word, (probably data sections?)
      - ~R_ARM_REL32~,   any 32-bit word
      - ~R_ARM_ABS16~,   any 16-bit halfword (probably data sections?)
      - ~R_ARM_ABS8~,    any 8-bit byte
      - ~R_ARM_SBREL32~, any 32-bit word, relative to the section boundary

pros of the elf way:
- don't have to have the assembler present to relocate
- relocations can work at program load time, rather than assembly time (dynamic loader)

as such, I'm going to convert to this model; the instructions will encode relocations as tuples
like ~(label fillptr (reloc-type args))~, and relocation time can use the reloc-type to do the
actual in-place patching.

** elf

elf is pretty set on various posixy things, I don't need that, I can just marshal to external reps

#+begin_src
  (%compiled-module
    (export . (exported exported2 exported3))
    (import . ((module name defun) ...)
    (code   . #vu8(0 0 0 ....)
    (reloc  . ((label offset (reloc-type arg)) ...)
#+end_src

then "execution" is, like on linux, the composing of the modules into a memory space and jumping into it
c v
* <2023-12-05 Tue>

~(define)~ and ~(pseudo)~ seem like they're working!

Also, I read an interesting blog post positing an arm emulator as a unit testing framework; basically:

#+begin_src
(block some-function (:callconv)
  (do
    (some)
    (stuff)))

(test
  ;; memory pseudo signals the emulator to place the values in memory
  (memory #x1200 (word #x22334455))

  ;; non-test are executed
  (bl some-function)

  ;; assert pseudo signals to do the tests on the emulated cpu
  (assert (reg-eq? pc lr))
  (assert (memory-eq? #x4032 #\h)))
#+end_src

The `test` blocks are normally ignored by the assembler, but when running in "test" mode,
insert breakpoint calls, and then assert the state of an emulated cpu + memory.

Interesting idea, and it would only require a somewhat minimal cpu emulation, because we don't
need all the various devices, only the cpu and the ability to control the visible memory.

See:
https://mos.datatra.sh/guide/unit-testing.html

* <2023-12-04 Mon>
well, this is cool!!

- run assembler test, it outputs a binary file
- at byte 512 is #xAA55, which is signal that this is a boot sector

- qemu-system-arm -machine raspi1b -kernel a.out -s -S
- eabi-arm-none-gdb
  - target remote localhost:1234
  - layout asm
  - si

it booted!
kinda!

* <2023-12-04 Mon>
** scoped labels

- ~scopes~ is a stack of symbols
  - '() means the top-level
  - the car of the stack is the current scope

- ~labels~ is an alist of alists
  - ~((label . ((scope-sym . offset) (scope-sym . offset))))~

- ~push-label~
  - adds a label at the current offset to the current scope

- ~push-reloc~
  - adds a relocation entry, which includes the _current stack of scopes_

- ~fixup-reloc~
  iterates through the saved stack of scopes, looking for a label that matches
  both the scope and symbol name.

  since top-level labels are stored with the empty scope as a key, they're
  naturally included in the search

*** example

#+begin_src scheme
  (label foo)
  (some-instruction)
  (block name ()
    (some-instruction)
    (bl ?q $exit)
    (some-instruction)
    (bl ?q $enter))
  (some-instruction)
  (bl foo)
#+end_src

* <2023-11-30 Thu>

At the high level, there's the assembler syntax itself:

#+begin_src scheme
  (assemble

   ;; opcodes are instruction mnemonics
   (mov r1 (r2 lsl 2))
   (adcs r1 r3 r2)

   ;; unquote and unquote-splice access the compile-time environment
   (mov r1 (r2 lsl ,(name 1 2)))

   ;; labels capture the current offset
   (label name)

   ;; blocks are labels with bodies that may use some block-specific syntax
   ;; $enter is a virtual label for just before the block prologue (flags) (more or less synonym for the block name)
   ;; $start is a virtual label for just after  the block prologue (flags) (for tail-cails)
   ;; $end   is a virtual label for just before the block epilogue (flags) (for early exit)
   ;; $exit  is a virtual label for just after  the block epilogue (flags) (for data offsets, maybe)
   (block name ()
     (mov r1 (r2 lsl 2))
     (adcs r1 r3 r2))

   ;; definitions are valid at compile-time
   (define (name a1 a2)
     (some-calc a1 (ulation a2)))

   ;; you can import definitions from elsewhere as well
   (import (miriam asm prelude))

   ;; pseudos syntactically modify the opcode forms
   ;; and run in the compile-time environment (macros)
   (pseudo (movi rd value)
     (movw rd ,(b&  value #xFFFF))
     (movt rd ,(b>> value 16))))
#+end_src

#+begin_src scheme
  (org   #x1000)
  (entry _start)

  (extern sys-exit)

  (pseudo (movimm32 reg imm)
    (if/let ((imm (u/s-word imm)))
      `((movw ,reg ,(b& imm #xFFFF))
        (movt ,reg ,(b>> imm 16) (lsl 16))))
    (syntax-error "expected imm to be a u/s-word"))

  (procedure _start (naked)
    (ldr r0 instr)
    (ldr r1 outstr)
    (mov r3 0)

    (movimm32 instr)

    (block
      (ldrb r2, (r0 ++), #1)
      (cmp r2 0)
      (b ?eq $end)

      (cmp r2 r3)
      (b ?eq $start)

      (strb r2 (r1 ++) #1)
      (mov r3 r2)
      (b $start))

    (bl null-write)
    (bl sys-exit))

  (procedure null-write ()
    (block
      (ldrb r1 r0)              ; load the byte from the string
      (cmp  r1 0)               ; if we've hit the null-terminator, bail
      (b ?eq $end)
      (add r0 r0 #1)            ; otherwise, incr the pointer and loop
      (b $start))

    (ldr r2 sp -4)              ; get the stored input address into r2
    (sub r1 r0 r2)              ; calculate length
    (ret))

  (data ()
    (instr   (res "I just want this thiiiing to woooork!"))
    (outstr  (res (bytes 128))))
#+end_src
