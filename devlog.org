#+TITLE:   Devlog/Ideas
#+AUTHOR:  Jon Raphaelson
#+EMAIL:   jon@accidental.cc

I'm working on a from-scratch scheme operating system.

* general plan

- an ARMv7 assembler (r7rs, run on host)

- a pre-scheme compiler (r7rs, runs on host)
  - compiled to native ARMv7 code (through assembler)
  - dialect of scheme, no gc (manual memory)
    - probably still has call/cc, since we're compiling to cps anyway

- a bytecode vm and garbage collector, written in our pre-scheme
  - which can be booted on an rpi (rg55xx?)
  - multiprocessor?
    - the vm should be able to run independently on all cores
    - study BEAM

- a compiler for scheme to our bytecode vm
  - "scheme" - this doesn't actually have to be a scheme
  - if it's not 100%, it means writing a bunch of library code
    - but rewriting srfis is probably good for my personal growth

- a rewrite of the assembler and pre-scheme compiler to run on the bytecode compiler

- an os written in the dialect
  - continuations as callbacks
  - system level gc? system-wide s-expr based data types?

- a graphical shell for the os
  - simple tiled, but processes should get regions to draw

- a text adventure game (zork)
- a pong game
- a tetris game
- a web browser? gopher maybe?

* latest how to:

** <2023-12-04 Mon>

this builds a raw binary output file, which can be run in qemu!

#+begin_src
$ guile --r7rs -L ./scm ./tests/assembler-tests.scm
$ qemu-system-arm -machine raspi2b -device loader,file=a.bin,addr=0x20 -Ss
#+end_src

in another terminal

#+begin_src
$ arm-none-eabi-gdb
> layout asm
> layout reg
> target remote localhost:1234
> si ; to single step (code starts at 0x20)
#+end_src

** <2023-11-24>

#+begin_src
$ guile --r7rs -L ./scm --fresh-auto-compile
> ,m (miriam assembler opcodes)
> (debug-emit (ldr r0 (++ r1) #x58))
#+end_src

* devlog
** <2023-12-05 Tue>

~(define)~ and ~(pseudo)~ seem like they're working!

Also, I read an interesting blog post positing an arm emulator as a unit testing framework; basically:

#+begin_src
(block some-function (:callconv)
  (do
    (some)
    (stuff)))

(test
  ;; memory pseudo signals the emulator to place the values in memory
  (memory #x1200 (word #x22334455))

  ;; non-test are executed
  (bl some-function)

  ;; assert pseudo signals to do the tests on the emulated cpu
  (assert (reg-eq? pc lr))
  (assert (memory-eq? #x4032 #\h)))
#+end_src

The `test` blocks are normally ignored by the assembler, but when running in "test" mode,
insert breakpoint calls, and then assert the state of an emulated cpu + memory.

Interesting idea, and it would only require a somewhat minimal cpu emulation, because we don't
need all the various devices, only the cpu and the ability to control the visible memory.

See:
https://mos.datatra.sh/guide/unit-testing.html

** <2023-12-04 Mon>
well, this is cool!!

- run assembler test, it outputs a binary file
- at byte 512 is #xAA55, which is signal that this is a boot sector

- qemu-system-arm -machine raspi1b -kernel a.out -s -S
- eabi-arm-none-gdb
  - target remote localhost:1234
  - layout asm
  - si

it booted!
kinda!

** <2023-12-04 Mon>
*** scoped labels 

- ~scopes~ is a stack of symbols
  - '() means the top-level
  - the car of the stack is the current scope

- ~labels~ is an alist of alists
  - ~((label . ((scope-sym . offset) (scope-sym . offset))))~

- ~push-label~
  - adds a label at the current offset to the current scope

- ~push-reloc~
  - adds a relocation entry, which includes the _current stack of scopes_

- ~fixup-reloc~
  iterates through the saved stack of scopes, looking for a label that matches
  both the scope and symbol name.

  since top-level labels are stored with the empty scope as a key, they're
  naturally included in the search

**** example

#+begin_src scheme
  (label foo)
  (some-instruction)
  (block name ()
    (some-instruction)
    (bl ?q $exit)
    (some-instruction)
    (bl ?q $enter))
  (some-instruction)
  (bl foo)
#+end_src

** <2023-11-30 Thu> 

At the high level, there's the assembler syntax itself:

#+begin_src scheme
  (assemble

   ;; opcodes are instruction mnemonics
   (mov r1 (r2 lsl 2))
   (adcs r1 r3 r2)

   ;; unquote and unquote-splice access the compile-time environment
   (mov r1 (r2 lsl ,(name 1 2)))

   ;; labels capture the current offset
   (label name)
 
   ;; blocks are labels with bodies that may use some block-specific syntax
   ;; $enter is a virtual label for just before the block prologue (flags) (more or less synonym for the block name)
   ;; $start is a virtual label for just after  the block prologue (flags) (for tail-cails)
   ;; $end   is a virtual label for just before the block epilogue (flags) (for early exit)
   ;; $exit  is a virtual label for just after  the block epilogue (flags) (for data offsets, maybe)
   (block name ()
     (mov r1 (r2 lsl 2))
     (adcs r1 r3 r2))

   ;; definitions are valid at compile-time
   (define (name a1 a2)
     (some-calc a1 (ulation a2)))

   ;; you can import definitions from elsewhere as well
   (import (miriam asm prelude))

   ;; pseudos syntactically modify the opcode forms
   ;; and run in the compile-time environment (macros)
   (pseudo (movi rd value)
     (movw rd ,(b&  value #xFFFF))
     (movt rd ,(b>> value 16))))
#+end_src

#+begin_src scheme
  (org   #x1000)
  (entry _start)

  (extern sys-exit)

  (pseudo (movimm32 reg imm)
    (if/let ((imm (u/s-word imm)))
      `((movw ,reg ,(b& imm #xFFFF))
        (movt ,reg ,(b>> imm 16) (lsl 16))))
    (syntax-error "expected imm to be a u/s-word"))

  (procedure _start (naked)
    (ldr r0 instr)
    (ldr r1 outstr)
    (mov r3 0)

    (movimm32 instr)

    (block
      (ldrb r2, (r0 ++), #1)
      (cmp r2 0)
      (b ?eq $end)

      (cmp r2 r3)
      (b ?eq $start)

      (strb r2 (r1 ++) #1)
      (mov r3 r2)
      (b $start))

    (bl null-write)
    (bl sys-exit))

  (procedure null-write ()
    (block
      (ldrb r1 r0)              ; load the byte from the string
      (cmp  r1 0)               ; if we've hit the null-terminator, bail
      (b ?eq $end)              
      (add r0 r0 #1)            ; otherwise, incr the pointer and loop
      (b $start))               

    (ldr r2 sp -4)              ; get the stored input address into r2
    (sub r1 r0 r2)              ; calculate length
    (ret))

  (data ()
    (instr   (res "I just want this thiiiing to woooork!"))
    (outstr  (res (bytes 128))))
#+end_src

* scratch

- what's in the compile time environment

  - opcodes
    - this is a function that takes the arguments and emits to the output object
  - psuedo-ops
    - this is a function that takes the arguments and emits opcodes, which are then compiled
  - definitions
    - this is a function that 
